#+hugo_base_dir: ./
#+hugo_section: blog

#+hugo_weight: auto
#+hugo_auto_set_lastmod: t
#+hugo_menu: :menu nil

#+author: Will Clarke

# How to use this:
# - Make sure you're using emacs
# - Make sure you've got =ox-hugo= installed (DOOM ftw)
# - SPC M e H A
# (secondary -> export -> hugo -> all)

* Blog Ideas
** Force a script to run as root (sudo) :unix:bash:
:PROPERTIES:
:EXPORT_FILE_NAME: force-a-script-to-run-sudo
:EXPORT_DATE: 2020-07-16
:END:
Just chuck this in at the start of a bash script and it'll ensure the rest of the script is run by the root user:
#+begin_src sh
#!/usr/bin/env sh
[ `whoami` = root ] || { sudo "$0" "$@"; exit $?; }
#+end_src

** Trying to get Go modules to play ball with private repos? :golang:
:PROPERTIES:
:EXPORT_FILE_NAME: go-modules-with-private-repos
:EXPORT_DATE: 2020-07-08
:END:
=go= modules are wonderful. All go code should use them.

It can still be a bit tricky getting private repos to work with =go mod=. Maybe these tips help... ¯\_(ツ)_/¯


- Set up =SSH= keys with your version control vendor
- Add the following to your =~/.gitconfig=:
  #+BEGIN_SRC bash
[url "ssh://git@github.com/"]
	insteadOf = https://github.com/
[url "ssh://git@gitlab.com/"]
  insteadOf = https://gitlab.com/
[url "ssh://git@bitbucket.org/"]
  insteadOf = https://bitbucket.org/
  #+END_SRC
- Add the offending repo as a *private repo*:
  #+BEGIN_SRC bash
go env -w GOPRIVATE=gitlab.com/you/your-project,github.com/someone/their-project
  #+END_SRC
:
** Ask stupid questions
:PROPERTIES:
:EXPORT_FILE_NAME: ask-stupid-questions
:EXPORT_DATE: 2020-06-27
:END:
Stupid questions aren't stupid.
It's important to clarify things rather than working on assumptions or guesses.
If you don't know about something, it's not your fault. It's only your fault if you *don't* ask.

It can be scary to admit that you don't know stuff... but it's worth trying (or pretending) to be confident & ask them. Like anything, it'll become easier to ask stupid questions the more you ask.

Here are some stupid questions in case you can't think of any off the top of your head:
- Why are we building this?
- What's this acronym?
- Why would a customer want to do this?
- Is this MVP really minimum?
- Is this MVP really viabale?
- Why are we doing this this way? Could this approach work?
- How are we measuring X?

** How to find rows which don't exist in a table :sql:
:PROPERTIES:
:EXPORT_FILE_NAME: find-sql-rows-which-dont-exist-in-table
:EXPORT_DATE: 2020-01-08
:END:

I was recently stumped for a while trying to find rows that *didn't* exist in my SQL table.

What I needed was to create a fake table (=WITH ...=), =JOIN= it onto my real table... and only select those which were =NULL= for the real table.

In the following example, I'm trying to find whether either =bob= or =andrea= don't exist in the database:

#+begin_src sql
WITH expected(email) AS (
VALUES
('bob@example.com'),
('andrea@example.com')
)
SELECT email
FROM expected
LEFT JOIN my_real_table_name t1
ON t1.email_address = expected.email;
WHERE t1.email_address IS NULL
#+end_src
** Document EVERYTHING!!! :documentation:
:PROPERTIES:
:EXPORT_FILE_NAME: document-everything
:EXPORT_DATE: 2020-03-01
:END:

People leave jobs all the time. People get run over by busses or win the lottery. People forget stuff.

It's important to document things, especially technical things.

#+BEGIN_SRC
code != documentation
#+END_SRC

Source code explains *how* things work... it's simply telling the computer the algorithm you want run.
What's not often mentioned is wider context.

- Why do we want this thing at all?
- What problem does it solve?
- Why don't we approach this in a different way?
- What are the current constraints? Is there time / business / financial pressure?
- Is this meant to be scalable or an MVP?
- What does this object / table represent?

Use comments and documentation widely to make it easier for the next person - often you.

** Get things done > tech used :product:tech:
:PROPERTIES:
:EXPORT_FILE_NAME: getting-things-done
:EXPORT_DATE: 2019-12-10
:END:

Technology is a lever. It lets us do things.

As Steve Jobs said:
> Man is a toolmaker, has the ability to make a tool to amplify the amount of inherent ability that he has.


{{< youtube 4x8wTj-n33A >}}



The whole point of technology is that it let's us *do* things.

As a software engineer, it can be tempting to fall into the trap of spending loads of time optimising your developer environments.

- Which shiny new thing should I use?
- Is there a vim plugin to save me 3 seconds per day?
- Can I [[https://github.com/NARKOZ/hacker-scripts][automate a coffee machine from my terminal?]]

These are all loads of fun, and you learn loads by doing them... but the end result is just that you'll be better at doing a (potentially very specific) job in the future.

Technology can impact every facet of our lives for enormous good. We have the ability to improve the world *loads*... and there's more to technology than just a slick development environment.

Maybe try finishing that side-project, or sitting down and thinking what you really want to *achieve*, rather than *how*.

** Enjoy it!
:PROPERTIES:
:EXPORT_FILE_NAME: enjoy-it
:EXPORT_DATE: 2020-05-27
:END:
You're likely to spend a significant percentage of your waking life working. You may as well try to enjoy it.

Money's kinda pointless if you're miserable earning and spending it.

If you're doing something you don't like, you should seriously consider making a change.

You can:
- try to change your teams
- try to change your hours
- try to change your hour-flexibilty
- try to change your jobs
- try to change your company
- try to change your projects
- try to change your managers
- try to change your industries
- try to change the technology you work with
- try to learn more stuff
- try to change your perspectives:
  - try to get more interested with what you do on a day-to-day way
  - try to engage more with your company's *product*
  - try to engage more with your company's *decisions*
  - try to take more ownership over what you're doing. A wrong decision may be better than no decision at all.

Life should be fun. Play around a bit and don't take anything toooo seriously. Enjoy it!

** Boring product names FTW :product:tech:
:PROPERTIES:
:EXPORT_FILE_NAME: boring-product-names-ftw
:EXPORT_DATE: 2019-07-11
:END:
In a company I worked at recently, we released a fantastic shiny-new thing.
It was a smaller version of another product called `cargo`, which did something related to packaging.

The question is, what should we call it?
Here are some names we came up with:
- =parcel=
- =package=
- =freight=
- =cargo-mini=
- =gateway=
- =specific-and-boring-product-description=
- =catalyst=

Any guesses which are the best names?

Our developers and users already knew about =cargo=. They had the mental context in their head. Because of this, =cargo-mini= makes sense as a smaller version of =cargo=.
I'm quite a fan of absurdly verbose but specific names, so I'm also a fan of =specific-and-boring-product-description=

** Defaults are good. Try them out! :tips:unix:
:PROPERTIES:
:EXPORT_FILE_NAME: defaults-are-good
:EXPORT_DATE: 2019-08-10
:END:

Most defaults have been carefully thought out. It's worth at least looking over them before deciding that they're useless & old-fashioned.

While it's true that many defaults are the result of some old-fashioned constraints (eg. =QWERTY= keyboard or the vim homerow being one key to the left), it may be worth your time just accepting their flawed premises and trying to use them anyway. There's value if people are also using them.

If your vim config is totally unique to you (or you're a =dvorak= user), you'll have a hard time pairing with someone else or =SSH=-ing into a server.

The creators of customisable products have hopefully thought long and hard about the best way to use *their* creations. They'll be far more invested in making it work well than you will and they'll have a vision of how they want their products being used.

Sometimes it's sensible to just accept defaults.

** Cron is cool :unix:shell:bash:
:PROPERTIES:
:EXPORT_FILE_NAME: cron-is-cool
:EXPORT_DATE: 2019-06-08
:END:
Cron jobs have a slightly terrifying syntax.
But there are loads of easy online [[https://crontab-generator.org/][tools like this one to help.]]

It can be really useful to have background jobs doing all sorts of things in the background.

The whole point of computers is to automate stuff... and =cron= is a really easy UNIX-y way of doing this.

Disclaimer: For one-off scripts, cron jobs can be great...but it doesn't scale particularly well. Eg. if you need to syncronise lots of background jobs, it's probably better to look for something else.

** Automate Repetitive Tasks
:PROPERTIES:
:EXPORT_FILE_NAME: automate-repetitive-tasks
:EXPORT_DATE: 2019-05-02
:END:

Computers are good at doing boring things.
Humans are too, but humans are also good at doing other, more interesting and creative things.

In every job I've been at, there have always been loads of ways to save human time by telling a computer to do some stuff instead of doing it manually.
This is especially true for non-super-technical areas; there could be lots of delicious low-hanging fruit.

You don't even need to be able to code to do loads of stuff; services like [[https://ifttt.com/][IFTTT]] or [[https://docs.google.com/spreadsheets/][Google sheets]] have lots of automatable functionality baked in.

In the past I've save loads of time by completely automating:
- Sending daily emails to clients about latest statistics (with some top-level analysis)
- Creation & management of Adwords campaigns
- Daily parsing of reports (& inserting into a database)

https://imgs.xkcd.com/comics/is_it_worth_the_time_2x.png

The trick here is to pick your battles. Some tasks are easy to automate (those which involve structured data). Others are difficult.
But always remember to keep tabs on where you spend your time; you may be able to free up a lot of time by some simple automation!

** jq is a cool tool :bash:unix:
:PROPERTIES:
:EXPORT_FILE_NAME: jq-is-a-cool-tool
:EXPORT_DATE: 2018-06-08
:END:
[[https://stedolan.github.io/jq/][=jq=]] is pretty cool.
It's a command-line utility that interacts with =JSON=.

I only recently discovered that it does *loads* more than just pretty-printing =JSON=.

You can =map= over it and do really quite complex data processing with =jq=.

I recently had to extract some data from an API and ended up piping into this:

#+begin_src bash
jq '.Chart.Purchases | map((. | first | tostring) + ", " + (. | last  | tostring) )'
#+end_src

It's really flexible and nice to use!

I'd recommend people have a quick browse through the [[https://stedolan.github.io/jq/tutorial/][jq examples and tutorial]] just so they know the full extent of what =jq= can do.

** Maybe try vim :vim::
:PROPERTIES:
:EXPORT_FILE_NAME: maybe-try-vim
:EXPORT_DATE: 2019-04-08
:END:
=vim= people like to talk about =vim= and often don't shut up about it.

It takes a long time to learn & adapt to modal editing and all of =vim='s esoteric keybindings.

Despite that, it's really popular. Perhaps people are onto something?

If you edit text for a living, it's probably worth your while looking into learning the basics of =vim= properly (no arrow keys, that's cheating!).


[[file:static/images/doit.gif]]

** We should all know git :git:
:PROPERTIES:
:EXPORT_FILE_NAME: we-should-all-know-git-well
:EXPORT_DATE: 2019-03-08
:END:

Version control's mega important.
I bet you used it even at school, saving stuff as =important-thing-VERSION-4.doc=

There's so much to learn about git. And most of us could afford to know a bit more about how it works.

- =reflog= has saved my life many times
- shortcuts like =git checkout -= save loads of time
- [[https://github.com/git/git/tree/master/contrib/completion][completion scripts]] can make your life easier & show options you didn't know about

If you don't already, it's probably worth curating a =~/.gitconfig= that you check into... =git=... and store somewhere.

** TODO Have a broad understanding of what different tools can do for you
# :PROPERTIES:
# :EXPORT_FILE_NAME: document-everything
# :EXPORT_DATE: 2019-06-08
# :END:
eg. jq
** learn some basic sql :sql:
# :PROPERTIES:
# :EXPORT_FILE_NAME: document-everything
# :EXPORT_DATE: 2019-06-08
# :END:
** learn some basic excel / google spreadsheet operations
# :PROPERTIES:
# :EXPORT_FILE_NAME: document-everything
# :EXPORT_DATE: 2019-06-08
# :END:
Use the right tool for the job!
** Record shell commands / sql queries you run
# :PROPERTIES:
# :EXPORT_FILE_NAME: document-everything
# :EXPORT_DATE: 2019-06-08
# :END:
they may be useful in the future!
Documentation!
** get comfortable creating bash executables
# :PROPERTIES:
# :EXPORT_FILE_NAME: document-everything
# :EXPORT_DATE: 2019-06-08
# :END:
** keep track of handy hints
# :PROPERTIES:
# :EXPORT_FILE_NAME: document-everything
# :EXPORT_DATE: 2019-06-08
# :END:
** Take logging seriously
** learn the difference between functions & methods
** `.env` files are your friend
** use ssh git github
git config --global url."git@github.com:".insteadOf "https://github.com/"
** Priotisation is stupidly important.
Your job isn't to just make stuff. It's to make the *right* stuff
** Learn the basics of HTTP
Get comfy with command-line cURL request
** map out all domain concepts before doing anything involving them
You need to *understand* things before you can fix / improve / work on them
** have fun along the way
** try static typing.. it can catch loads of bugs
** guids > ids normally
** get familiar with ssh & ~/.ssh/config  && /etc/hosts files
** screenshots help a lot
** over communicationn is tricky
** formatting & style guides are overrated
** don't over-optimise
** don't over-promise
** haters gonna hate
** scepticism is good
** read documentation - not just stack overflow
** adding sql indexes is cool
** Get used to using AWS / GCP
** Don't just build things! Complete them! Market them!
Try to create a side-hustle or business or portfolio
** Invest time in staring at Trello / Jira. You're also a product person
** lambdas are the future! serverless FTW
** Keep learning, reading and absorbing stuff
** Learn more than one language. Get a broad base
** Be confident
you're getting paid to work with people rather than be shy or polite
** Move slowly
but deliberately
** keep things simple
do things the simple way
only generalise when you have to
don't shy away from doing this manually
** Don't be scared to read some source code & try to understand it
** time-box things.
Don't get carried away and spend all your time doing something inefficient
** Reevaluate priorities reguarly
pomodoro technique
** Sometimes you just need a load of time to do things
** learn some s3 command lines
https://github.com/aws-samples/aws-modern-application-workshop/ is good
** Learn the basics - don't take shortcuts.
Eg. implement password hashing and salting yourself, rather than a library. It's important to see how stuff works
** Document starting a new Hugo blog
** Document X230 set up!
** Standing desks are cool
** exercise is important - just walking's fine. good for clearing the mind
** Wake up early and do stuff in the morning
** Get used to using docker!±
docker run -it --rm alpine mkpasswd
** passwd & /etc/shadow & /etc/passwd
** use git everywhere!
